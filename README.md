# Config3
YAML convertter
Инструмент командной строки для учебного конфигурационного языка
Назначение и требования

По условию задания необходимо разработать утилиту командной строки, которая принимает на стандартный вход текст на учебном конфигурационном языке и преобразует его в выходной файл на языке YAML. Инструмент должен:

Корректно читать вход из STDIN и записывать результат в файл, путь к которому передаётся через ключ ‑o/--output.

Поддерживать однострочные (REM …) и многострочные ((comment … )) комментарии.

Распознавать числа (с обязательной дробной частью), строки (начинаются с @ и заключены в двойные кавычки), массивы ([значение; …]) и словари ({ключ : значение, …}).

Позволять объявлять константы на этапе трансляции с помощью имя := значение и вычислять константные выражения в постфиксной записи | … |. В константных выражениях поддерживаются операции сложения, вычитания, умножения, остатка от деления (mod()) и конкатенации (concat()).

При обнаружении синтаксической ошибки выводить диагностическое сообщение с номером строки и столбца и завершать работу с ненулевым кодом.

Покрывать тестами все конструкции языка, в том числе их вложения.

Структуры данных языка YAML – последовательности и отображения – имеют простой синтаксис. Запись списка начинается с дефиса и пробела для каждого элемента, а отображения используют формат «ключ : значение»
docs.ansible.com
docs.ansible.com
. YAML допускает запись коллекций в «потоковой» форме в фигурных и квадратных скобках
docs.ansible.com
. Числа с дробной частью записываются без кавычек, в том числе в экспоненциальной форме
yaml.org
.

Архитектура решения
Общий обзор

Реализация написана на Java 17. Основной класс ConfigConverter содержит точку входа программы. Он разбирает аргументы командной строки (ожидается параметр ‑o/--output), считывает исходный текст из STDIN, передаёт его парсеру и, в случае успешного разбора, сериализует результат в YAML‑файл. При ошибках парсер генерирует исключение ParseException, которое перехватывается и выводится в STDERR.

Парсер

Класс Parser реализует рекурсивный нисходящий разбор грамматики. Внутри парсера хранятся:

Текущая позиция в строке, номер строки и столбца – для точной диагностики ошибок.

Карта констант Map<String, Object>, доступных для выражений.

Переменная lastValue, в которую сохраняется последнее выраженное значение (последний объект, не являющийся объявлением константы).

Метод parse() циклически пропускает пробельные символы и комментарии, затем определяет, является ли очередная конструкция объявлением константы (вид name := value). Если да, то имя и значение разбираются и сохраняются в карте констант, а результат не влияет на lastValue. Во всех остальных случаях вызывается parseValue(), и возвращённый объект запоминается как последний. После разбора всего входа возвращается lastValue (при отсутствии значений – null).

Парсер поддерживает:

Комментарии. Метод skipWhitespaceAndComments() пропускает пробелы, однострочные комментарии, начинающиеся с REM, и многострочные, заключённые в (comment … ). При обработке комментариев корректно обновляются номера строк и столбцов.

Строки. parseString() ожидает символ @, затем открывающую двойную кавычку. Всё содержимое до закрывающей кавычки возвращается как строка без интерпретации escape‑последовательностей.

Числа. parseNumberLiteral() читает опциональный знак, последовательность цифр, точку и обязательную дробную часть. При отсутствии дробной части генерируется исключение. Внутри константных выражений допускаются и целые числа (парсер проверяет наличие десятичной точки только для «обычных» значений).

Массивы и словари. parseArray() и parseDictionary() создают соответственно List<Object> и Map<String,Object>. Массивы используют разделители ;, словари – ,. Разрешена завершающая точка с запятой или запятая перед закрывающей скобкой. Ключи словаря должны соответствовать [a-z]+.

Константные выражения. parseConstantExpression() обрабатывает всё между символами | как последовательность токенов, разделённых пробелами. Для вычисления используется стек. Поддерживаются операции +, -, *, mod() и concat(). Токены, соответствующие именам, подменяются значениями из карты констант; числовые литералы преобразуются в Double; строковые литералы в выражениях записываются в виде @"…" и помещаются в стек как строки. В конце выражения на стеке должен остаться ровно один элемент.

Операции реализованы в виде приватных методов:

addValues(), subtractValues(), multiplyValues() – принимают два числа и возвращают результат операций сложения, вычитания или умножения.

modValues() – вычисляет остаток от деления; аргументы приводятся к целым типам.

concatValues() – реализует конкатенацию строк и объединение списков. При смешивании строки и списка строка рассматривается как одноэлементный список. При ошибочных типах генерируется исключение.

Генератор YAML

Класс YamlEmitter выполняет сериализацию произвольного объекта (карта, список, примитив) в YAML. Он не использует сторонних библиотек и выдаёт данные в «блочном» стиле:

Для отображений каждая пара «ключ : значение» выводится с соответствующим отступом; вложенные структуры переходят на новую строку.

Для последовательностей каждый элемент предваряется - и пробелом
docs.ansible.com
.

Строки всегда берутся в двойные кавычки, а обратные косые черты и кавычки внутри них экранируются, чтобы избежать YAML‑индикаторов
docs.ansible.com
. Числа и логические значения выводятся без кавычек. YAML допускает сокращённую запись коллекций в фигурных и квадратных скобках
docs.ansible.com
, но генератор использует блочный стиль для наглядности.

Числа с дробной частью в YAML записываются без кавычек, допускаются как фиксированная, так и экспоненциальная форма. В спецификации языка YAML приведён пример записи различных представлений одного числа: каноническое 1.23015e+3, экспоненциальное 12.3015e+02 и «фиксированное» 1230.15
yaml.org
.

Тесты

Файл ConfigConverterTest.java содержит небольшой набор тестов, запускаемых из метода main. Для проверки используются утверждения assert. В тестах предусмотрены случаи:

Числа и строки – разбирается число 1.0 и строка @"Hello".

Массивы и словари – проверяются простые и вложенные структуры, в том числе словарь, содержащий список словарей.

Константы и выражения – объявление констант, использование их в выражениях и вычисление выражений +, *, mod() и concat().

Диагностика ошибок – попытка разобрать выражение с отсутствующей закрывающей скобкой приводит к генерации ParseException.

Тесты выводят имя теста и статус «PASSED» или «FAILED», чтобы убедиться, что все конструкции языка корректно обрабатываются.
